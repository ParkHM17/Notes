# 操作系统

## 一、操作系统基础:airplane:

> 参考链接：[JavaGuide](https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80)

### 1.1 什么是操作系统？

- 操作系统（Operating System，简称OS）是**管理计算机硬件与软件资源的程序**，是计算机的基石。
- 操作系统本质上是一个**运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源**。
- **操作系统的存在屏蔽了硬件层的复杂性**。
- **操作系统的内核（Kernel）是操作系统的核心部分**，它负责系统的内存管理、硬件设备的管理、文件系统的管理以及应用程序的管理。内核是**连接应用程序和硬件的桥梁**，决定着系统的性能和稳定性。

![Kernel](操作系统.assets/Kernel_Layout.png)

### 1.2 系统调用

先来了解一下**用户态**和**系统态**。根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：

- 用户态（User mode）：用户态运行的进程可以**直接读取用户程序的数据**。
- 系统态（Kernel mode）：系统态运行的进程或程序**几乎可以访问计算机的任何资源**，不受限制。

那么什么是系统调用呢？运行的程序基本都是在用户态，如果调用操作系统提供的系统态级别的子功能就需要**系统调用了**！

也就是说在运行的用户程序中，**凡是与系统态级别的资源有关的操作**（如文件管理、进程控制、内存管理等)都**必须通过系统调用方式向操作系统提出服务请求**，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

- **设备管理**：完成设备的请求或释放，以及设备启动等功能。
- **文件管理**：完成文件的读、写、创建及删除等功能。
- **进程控制**：完成进程的创建、撤销、阻塞及唤醒等功能。
- **进程通信**：完成进程之间的消息传递或信号传递等功能。
- **内存管理**：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

## 二、进程和线程:airplane:

> 参考链接：[JavaGuide](https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B)

### 2.1 进程和线程的区别

从JVM的角度来说一下线程和进程之间的关系：

![JVM内存](操作系统.assets/微信截图_20220630222753.png)

从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区（JDK 1.8之后的元空间）**资源，但是每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**。

**所以**，**线程是进程划分成的更小的运行单位**，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上**各进程是独立的，而各线程则不一定**，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

### 2.2 进程有哪几种状态？

一般把进程大致分为5种状态：

- **创建状态（New）**：进程正在被创建，尚未到就绪状态。
- **就绪状态（Ready）**：进程**已处于准备运行状态**，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行。
- **运行状态（Running）**：进程正在处理器上上运行（单核CPU下任意时刻只有一个进程处于运行状态）。
- **阻塞状态（Waiting）**：又称为等待状态，**进程正在等待某一事件而暂停运行**，如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态（Terminated）**：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

![进程状态](操作系统.assets/d38202593012b457debbcd74994c6292.png)

### 2.3 进程间的通信方式

1. **管道/匿名管道（Pipes）**：用于具有**亲缘关系**的父子进程间或者兄弟进程之间的通信（Linux系统中在内存上）。

2. **有名管道（Names Pipes）**：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出（FIFO）**。有名管道以磁盘文件的方式存在，**可以实现本机任意两个进程通信**。

3. **信号（Signal）**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

4. **消息队列（Message Queuing）**：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。

   与管道不同的是消息队列**存放在内核**中，**只有在内核重启（即操作系统重启）或者显式地删除一个消息队列时，该消息队列才会被真正的删除**。消息队列可以实现消息的随机查询，**消息不一定要以先进先出的次序读取**，也可以按消息的类型读取。**消息队列克服了信号承载信息量少、管道只能承载无格式字节流以及缓冲区大小受限等缺点**。

5. **信号量（Semaphores）**：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

6. **共享内存（Shared memory）**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。**可以说这是最有用的进程间通信方式**。

7. **套接字（Sockets）**：此方法主要用于客户端和服务器之间通过网络进行通信。**套接字是支持TCP/IP的网络通信的基本操作单元**，可以看做是不同主机的进程之间进行双向通信的端点，简单的说就是通信两方的一种约定，用套接字中的相关函数来完成通信过程。

### 2.4 线程间的同步方式

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 2.5 进程的调度算法

为了确定首先执行哪个进程以及最后执行哪个进程以实现最大的CPU利用率，计算机科学家已经定义了一些算法，它们是：

- **先到先服务（FCFS）调度算法**：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
- **短作业优先（SJF）的调度算法**：从就绪队列中选出一个**估计运行时间最短**的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
- **时间片轮转调度算法**：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR（Round robin）调度。每个进程被**分配一个时间段**，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法**：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法**既能使高优先级的作业得到响应又能使短作业（进程）迅速完成**。因而它是目前**被公认的一种较好的进程调度算法**，UNIX操作系统采取的便是这种调度算法。
- **优先级调度**：为每个流程**分配优先级**，首先执行具有最高优先级的进程，依此类推。**具有相同优先级的进程以FCFS方式执行**。可以根据内存要求、时间要求或任何其他资源要求来确定优先级。

### 2.6 什么是死锁？

> 参考链接：[腾讯云](https://cloud.tencent.com/developer/article/1493418)

死锁是指两个或两个以上的进程在执行过程中，**由于竞争资源或者由于彼此通信而造成的一种阻塞的现象**，若无外力作用，它们都将无法推进下去。**此时称系统处于死锁状态或系统产生了死锁**，这些永远在互相等待的进程称为死锁进程。

### 2.7 死锁的四个条件

> 参考链接：[YON's Blog](https://yoncise.com/2017/07/29/%E6%AD%BB%E9%94%81/)、[腾讯云](https://cloud.tencent.com/developer/article/1493418)

注意，准确来说应该是**四个必要条件**：

- **互斥（Mutual exclusion）**：任一时刻, 一个资源仅能被一个进程独占。
- **占有并等待（Hold and wait）**：一个进程因请求资源得不到满足而等待时, 不释放已占有的资源。
- **不可剥夺（No preemption）**：任一进程不能从另一进程那里抢夺资源。
- **循环等待（Circular wait）**：存在一个循环等待链。

例如：两个线程各自持有一个无法共享（互斥）的资源，并且它们都需要获取（占有并等待）对方现在持有的资源才能进行下一步，但是它们又必须等对方释放了才能去获取（不可剥夺），于是A等待B，B也在等待A（循环等待）。如此这般，死锁就产生了。

### 2.8 解决死锁的办法

解决死锁的方法可以从多个角度去分析，一般的情况下，有**预防，避免，检测**和**解除**四种：

- **预防**：采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
- **避免**：系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**。
- **检测**：系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除**：与**检测**相配套的一种措施，用于**将进程从死锁状态下解脱出来**。

#### 预防