# MySQL

## 一、数据类型:airplane:

### 1.1 字段类型

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/db/sql-mysql/sql-mysql-theory.html#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B)

#### 整型

`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`分别使用8、16、24、32、64位存储空间，一般情况下越小的列越好。

注意：`INT(11)`中的数字只是规定了交互工具显示字符的个数，对于**存储和计算来说是没有意义的**。

#### 浮点数

`FLOAT`和`DOUBLE`为浮点类型，`DECIMAL`为高精度小数类型。

CPU原生支持浮点运算，但是不支持`DECIMAL`类型的计算，因此`DECIMAL`的计算比浮点类型需要更高的代价。

`FLOAT`、`DOUBLE`和`DECIMAL`都可以指定列宽，例如`DECIMAL(18, 9)`表示总共18位，取9位存储小数部分，剩下9位存储整数部分。

#### 字符串

主要有`CHAR`和`VARCHAR`两种类型，一种是定长的，一种是变长的。

`VARCHAR`这种变长类型能够节省空间，因为**只需要存储必要的内容**。但是在执行`UPDATE`语句时可能会使行变得比原来长，**当超出一个页所能容纳的大小时，就要执行额外的操作**。MyISAM会将行拆成不同的片段存储，而InnoDB则需要**分裂页**来使行放进页内。

`VARCHAR`会保留字符串末尾的空格，而`CHAR`会删除。

#### 时间和日期

MySQL提供了两种相似的日期时间类型：`DATETIME`和`TIMESTAMP`。

##### `DATETIME`

能够保存从1001年到9999年的日期和时间，精度为秒，使用**8字节**的存储空间。它与时区无关。

默认情况下，MySQL以一种可排序的、无歧义的格式显示`DATETIME`值，例如`2008-01-16 22:37:08`，这是ANSI标准定义的日期和时间表示方法。

##### `TIMESTAMP`

和UNIX时间戳相同，保存从1970年1月1日午夜（格林威治时间）以来的秒数，使用**4个字节**，只能表示从1970年到2038年。它和时区有关，也就是说**一个时间戳在不同的时区所代表的具体时间是不同的**。

MySQL提供了`FROM_UNIXTIME()`函数把UNIX时间戳转换为日期，并提供了`UNIX_TIMESTAMP()`函数把日期转换为UNIX时间戳。

默认情况下，如果插入时没有指定`TIMESTAMP`列的值，会将这个值设置为当前时间。

**应该尽量使用`TIMESTAMP`，因为它比`DATETIME`空间效率更高**。

### 1.2 选择优化的数据类型

- **更小的通常更好**：更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。
- **简单就好**：例如，整形比字符串操作代价更低；使用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等。
- **尽量避免`NULL`**：如果查询中包含可为`NULL`的列，对MySQL来说更难优化，因为可为`NULL` 的列使得索引、索引统计和值比较都更复杂。尽管把可为`NULL`的列改为`NOT NULL`带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为`NULL`的列；

#### 字符串类型

##### `VARCHAR`和`CHAR`

下面这些情况使用`VARCHAR`是合适的：

- 字符串的最大长度比平均长度大很多。
- 列的更新很少，所以碎片不是问题。
- 使用了像`UTF-8`这样复杂的字符集，每个字符都使用不同的字节数进行存储。

`CHAR`适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，`CHAR`也比`VARCHAR`更好，因为`CHAR`不容易产生碎片。

##### `VARCHAR(5)`和`VARCHAR(200)`

**更长的列会消耗更多的内存**，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。所以最好的策略是**只分配真正需要的空间**。

##### `BLOB`和`TEXT`

`BLOB`和`TEXT`都是为存储很大的数据而设计的数据类型，分别采用**二进制**和**字符方式**存储。

与其他类型不同，MySQL把每个`BLOB`和`TEXT`值当做一个**独立的对象**去处理。当`BLOB`和`TEXT`值太大时，InnoDB会使用**专门的“外部”存储区域来进行存储**，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

MySQL对`BLOB`和`TEXT`列进行排序与其他类型是不同的：它只对每个列的最前`max_sort_length`个字节而不是整个字符串做排序。同样的，MySQL也不能将`BLOB`或`TEXT`列全部长度的字符串进行索引。

#### 选择表示符（Identifier）

**整数类型通常是标识列的最佳选择**，因为它们很快并且可以使用`AUTO_INCREMENT`。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如`MD5()`、`SHA1()`或者`UUID()`产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致`INSERT`以及一些`SELECT`语句变得很慢：

- 因为**插入值会随机地写入到索引的不同位置**，所以使得`INSERT`语句更慢。这会导致叶分裂、磁盘随机访问。
- `SELECT`语句会变得更慢，因为**逻辑上相邻的行会分布在磁盘和内存的不同地方**。
- **随机值导致缓存对所有类型的查询语句效果都很差**，因为会使得缓存赖以工作的局部性原理失效。

## 二、基础架构:boat:

> 参考链接：[JavaGuide](https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84)

下图是MySQL的一个简要架构图，从下图可以很清晰的看到客户端的一条SQL语句在MySQL内部是如何执行的。

![MySQL架构图](MySQL.assets/13526879-3037b144ed09eb88.png)

MySQL主要由下面几部分构成：

- **连接器：**身份认证和权限相关（登录MySQL的时候）。
- **查询缓存：**执行查询语句的时候，会先查询缓存（MySQL `8.0`版本后移除，因为这个功能不太实用）。
- **分析器：**没有命中缓存的话，SQL语句就会经过分析器，分析器说白了就是要先看SQL语句要干嘛，再检查SQL语句语法是否正确。
- **优化器：**按照MySQL认为最优的方案去执行。
- **执行器：**执行语句，然后从存储引擎返回数据。执行语句之前会先判断是否有权限，如果没有权限就会报错。
- **插件式存储引擎**：主要负责数据的存储和读取，采用的是**插件式架构**，支持InnoDB、MyISAM、Memory等多种存储引擎。

## 三、存储引擎:boat:

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/db/sql-mysql/sql-mysql-engine.html)、[JavaGuide](https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)

### 3.1 InnoDB

MySQL默认的事务型存储引擎，**只有在需要它不支持的特性时，才考虑使用其它存储引擎**。

实现了四个标准的隔离级别，默认级别是**可重复读**（REPEATABLE READ）。在可重复读隔离级别下，**通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻读**。

**主索引是聚簇索引**，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

**内部做了很多优化**，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

**支持真正的在线热备份**，其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### 3.2 MyISAM

设计简单，数据以紧密格式存储。**对于只读数据，或者表比较小、可以容忍修复操作**，则依然可以使用它。提供了大量的特性，包括压缩表、空间数据索引等。

**不支持事务**。

**不支持行级锁**，只能对整张表加锁，**读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁**。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了`DELAY_KEY_WRITE`选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 3.3 比较

- 事务：InnoDB是事务型的，可以使用`Commit`和`Rollback`语句。
- 并发：MyISAM**只支持表级锁**，而InnoDB还支持行级锁。
- 外键：InnoDB支持外键。
- 备份：InnoDB支持在线热备份。
- 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM支持压缩表和空间数据索引。
- MySQL `5.5.5`之前，MyISAM是默认存储引擎；在`5.5.5`之后默认存储引擎变成了InnoDB。

## 四、索引详解:airplane:

> 参考链接：[JavaGuide](https://javaguide.cn/database/mysql/mysql-index.html#%E5%89%8D%E8%A8%80)

### 4.1 何为索引？

索引是一种用于**快速查询和检索数据的数据结构**。常见的索引结构有：B树、B+树和Hash。索引的作用就相当于书的目录。

### 4.2 索引优缺点

#### 优点

- 使用索引可以大大加快数据的检索速度（**大大减少检索的数据量**）, 这也是创建索引的最主要的原因。
- 通过**创建唯一性索引**，可以保证数据库表中**每一行数据的唯一性**。

#### 缺点

- 创建索引和维护索引需要**耗费许多时间**。当对表中的数据进行**增删改**的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

**使用索引一定能提高查询性能吗?**

大多数情况下，**索引查询都是比全表扫描要快的**。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

### 4.3 索引的底层数据结构

#### 哈希表

哈希表是键值对的集合，通过键（key）可快速取出对应的值（value），因此哈希表可以快速检索数据（接近O(1)）。

**为何能够通过key快速取出value呢？** 原因在于**哈希算法**（也叫散列算法）。通过哈希算法，可以快速找到key对应的index，找到了index也就找到了对应的value。

```
hash = hashfunc(key)
index = hash % array_size
```

![哈希算法](MySQL.assets/20210513092328171.png)

但是哈希算法有**Hash 冲突**问题：多个不同的key最后得到的index相同。通常情况下，常用的解决办法是**链地址法**。链地址法就是将**哈希冲突数据存放在链表中**。就比如JDK 1.8之前`HashMap`就是通过链地址法来解决哈希冲突的。不过，JDK 1.8以后`HashMap`为了**减少链表过长的时候搜索时间过长引入了红黑树**。

![红黑树解决哈希冲突](MySQL.assets/20210513092224836.png)

为了减少Hash冲突的发生，一个好的哈希函数应该**均匀地**将数据分布在整个可能的哈希值集合中。

既然哈希表这么快，**为什么MySQL没有使用其作为索引的数据结构呢？**

1. Hash冲突问题 ：虽然对于数据库来说这不算最大的缺点。
2. **Hash索引不支持顺序和范围查询是它最大的缺点**：假如要对表中的数据进行排序或者进行范围查询，那Hash索引可就不行了。

#### B树、B+树

B树也称**B-树**，全称为**多路平衡查找树**，B+树是B树的一种变体。B树和B+树中的“B”是Balanced（平衡）的意思。目前大部分数据库系统及文件系统都**采用B-树或其变种B+树作为索引结构**。

**B树和B+树两者有何异同呢？**

- B树的所有节点既存放键也存放数据，而B+树只有叶子节点存放键和数据，其他节点只存放键。
- B树的叶子节点都是独立的；B+树的叶子节点**有一条引用链指向与它相邻的叶子节点**。
- B树的检索过程相当于对范围内每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而**B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显**。

在MySQL中，MyISAM引擎和InnoDB引擎都是使用B+Tree作为索引结构，但是两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）

- MyISAM引擎中，B+Tree叶子节点的**data域存放的是数据记录的地址**。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则**取出其data域的值，然后以data域的值为地址读取相应的数据记录**。这被称为**非聚簇索引**。
- InnoDB引擎中，其**数据文件本身就是索引文件**。相比MyISAM，索引文件和数据文件是分离的，其**表数据文件本身就是按B+Tree组织的一个索引结构**，树的叶节点data域保存了完整的数据记录。**这个索引的key是数据表的主键**，因此InnoDB**表数据文件本身就是主索引**。这被称为**聚簇索引（或聚集索引）**，而其余的索引都作为辅助索引，**辅助索引的data域存储相应记录主键的值而不是地址**，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引**。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

### 4.4 索引类型

#### 主键索引（Primary Key）

数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为`NULL`，不能重复。

在MySQL的InnoDB的表中，当没有显式指定表的主键时，InnoDB会**自动检查**表中是否有唯一索引且不允许存在`NULL`值的字段，如果有则选择该字段为默认的主键；否则InnoDB将会自动创建一个6Byte的自增主键。

![主键索引](MySQL.assets/cluster-index.png)

#### 二级索引（辅助索引）

二级索引又称为辅助索引，是因为**二级索引的叶子节点存储的数据是主键**。也就是说，通过二级索引，可以定位主键的位置。

![二级索引](MySQL.assets/no-cluster-index.png)

##### 唯一索引（Unique Key）

唯一索引也是一种约束。唯一索引的属性列**不能出现重复的数据**，但是允许数据为`NULL`，一张表允许创建多个唯一索引。建立唯一索引的目的**大部分时候都是为了该属性列的数据的唯一性**，而不是为了查询效率。

##### 普通索引（Index）

普通索引的唯一作用就是为了**快速查询数据**，一张表允许创建多个普通索引，并允许数据重复和`NULL`。

##### 前缀索引（Prefix）

前缀索引只适用于**字符串类型的数据**。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为**只取前几个字符**。

##### 全文索引（Full Text）

全文索引主要是为了**检索大文本数据中的关键字信息**，是目前搜索引擎数据库使用的一种技术。MySQL 5.6之前只有MyISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。

### 4.5 聚集索引与非聚集索引

#### 聚集索引

聚集索引即**索引结构和数据一起存放**的索引。**主键索引属于聚集索引**。

在MySQL中，InnoDB引擎的表的`.ibd`文件就包含了**该表的索引和数据**，对于InnoDB引擎表来说，该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储**索引和索引对应的数据**。

##### 优点

聚集索引的**查询速度非常快**，因为整个B+树本身就是一个多叉平衡树，**叶子节点也都是有序的**，定位到索引的节点，就相当于定位到了数据。

##### 缺点

1. **依赖于有序的数据**：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在**插入时排序**，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大**：如果索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，**所以对于主键索引来说，主键一般都是不可被修改的**。

#### 非聚集索引

非聚集索引即**索引结构和数据分开存放**的索引。**二级索引属于非聚集索引**。

非聚集索引的叶子节点并不一定存放数据的指针，因为**二级索引的叶子节点就存放的是主键，根据主键再回表查数据**。

##### 优点

**更新代价比聚集索引要小**。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的。

##### 缺点

1. 跟聚集索引一样，非聚集索引也**依赖于有序的数据**。
2. **可能会二次查询(回表)**：这应该是非聚集索引最大的缺点了。当查到索引对应的指针或主键后，可能**还需要根据指针或主键再到数据文件或表中查询**。

