# Java中常用的注解

## `@Component`、`@Controller`、`@Repository`、`@Service`

- 参考链接：[知乎](https://zhuanlan.zhihu.com/p/137507309)、[Stack Overflow](https://stackoverflow.com/questions/6827752/whats-the-difference-between-component-repository-service-annotations-in)
- `@Component`：任何**Spring**管理组件的通用原型。
- `@Repository`：作用于**持久层**，主要用于数据库相关操作。
- `@Service`：作用于**服务层**，主要涉及复杂业务逻辑。
- `@Controller`：作用于**表现层**（SpringMVC），主要用于接收用户请求并调用服务层返回数据给前端页面。

## `@Controller`和`@RestController`

- 参考链接：[微信公众号](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485544&idx=1&sn=3cc95b88979e28fe3bfe539eb421c6d8&chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&token=1725092312&lang=zh_CN#rd)

- 单独使用 `@Controller` 不加 `@ResponseBody`的话一般使用在要返回一个**视图**的情况，这种情况属于比较传统的SpringMVC 的应用，对应于前后端不分离的情况。

  ![SpringMVC传统工作流程](常用注解.assets/640.png)

- `@RestController`只返回**对象**，对象数据直接以**JSON**或**XML**形式写入HTTP响应体中，这种情况属于**RESTful Web**服务，目前开发最常用的情况（前后端分离）。

  ![SpringMVC+@RestController](常用注解.assets/1451.png)

- `@RestController`=`@Controller`+`@RespnseBody`。其中`@ResponseBody`的作用是将`@Controller`的方法的返回对象通过适当的转换器转换为指定的格式后，写入到HTTP响应体中，通常用来返回Json或XML数据。

  ![Spring3.xMVC RESTful Web 服务工作流程](常用注解.assets/123.png)

## `@Value`

- 参考链接：[CSDN](https://blog.csdn.net/wangshuminjava/article/details/81476028)

- 使用`@Value`读取配置信息，有两种方式：

    - `${}`方式：属于**属性占位符**方式
    
      ```java
      @Value("${jdbc.url}")
      private String url;
      ```
    
      对应的配置方式
    
      ```xml
      <!--基于占位符方式 配置单个properties -->
      <context:property-placeholder location="conf/jdbc.properties"/>
      
      <!--基于占位符方式 配置多个properties -->
      <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
      	<property name="location" value="conf/jdbc.properties"/>
      </bean>
      ```
    
    - `#{}`方式：属于**SpEL表达式**方式
    
      ```java
      @Value("#{configProperties['jdbc.url']}")
      private String url;
      ```
    
      对应的配置方式
    
      ```xml
      <!--基于SpEL表达式 配置多个properties id值为configProperties 提供java代码中使用 -->
      <bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
          <property name="locations">
              <list>
                  <value>classpath:/conf/jdbc.properties</value>
              </list>
          </property>
      </bean>
      
      <!--基于SpEL表达式 配置单个properties -->
      <util:properties id="configProperties" location="classpath:conf/jdbc.properties"/>
      ```
      
## `@Component`和`@Bean`

- 参考链接：[Stack Overflow](https://stackoverflow.com/questions/10604298/spring-component-versus-bean)

- 作用对象不同：`@Component`作用于类，`@Bean`作用于方法。

- `@Component`通过类路径扫描自动检测和自动装配到Spring容器中。该类和创建的bean之间有一个**隐式**的一对一映射（即每个类对应一个bean）。这种方法对连接的控制非常有限，因为它纯粹是**声明性**的。

- `@Bean`用于**显式**声明单个bean，而不是让Spring自动声明。它将bean的声明与类定义解耦，并允许按照自己选择的方式创建和配置bean，所以它的**自定义性**更强。所以需要引用第三方库中的类需要装配到 Spring 容器时，只能通过 `@Bean` 来实现。

  ```java
  @Bean
  public OneService getService(status) {
      case (status) {
          when 1:
          return new serviceImpl1();
          when 2:
          return new serviceImpl2();
          when 3:
          return new serviceImpl3();
      }
  }
  ```

## `@Required`

- 参考链接：[W3Cschool](https://www.w3cschool.cn/wkspring/9sle1mmh.html)

- `@Required` 注解应用于 bean 属性的 **setter 方法**，它表明受影响的 **bean 属性在配置时必须放在 XML 配置文件中**，否则容器就会抛出一个 BeanInitializationException 异常，如下所示：

  Student.java文件：

  ```java
  import org.springframework.beans.factory.annotation.Required;
  public class Student {
     private Integer age;
     private String name;
     @Required
     public void setAge(Integer age) {
        this.age = age;
     }
     public Integer getAge() {
        return age;
     }
     @Required
     public void setName(String name) {
        this.name = name;
     }
     public String getName() {
        return name;
     }
  }
  ```

  Beans.xml文件：这里没有对属性age进行注解，所以会抛出异常。

  ```xml
  <context:annotation-config/>
  
  <!-- Definition for student bean -->
  <bean id="student" class="com.tutorialspoint.Student">
      <property name="name"  value="Zara" />
      <!-- try without passing age and check the result -->
      <!-- property name="age"  value="11"-->
  </bean>
  ```

## `@Autowired`和`@Resource`

- 参考链接：[掘金](https://juejin.cn/post/7022507865701089317)

- 相同点：`@Resource`和`@Autowired`都可以作为注入属性的修饰，在接口**仅有单一实现类**时，两个注解的修饰效果相同，可以互相替换，不影响使用。

- 不同点

  - `@Resource`是JDK原生的注解，`@Autowired`是Spring2.5 引入的注解

  - `@Resource`有两个属性**name**和**type**。Spring将`@Resource`注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用**name属性，则使用byName**的自动注入策略，而使用**type属性时则使用byType**自动注入策略。如果既不指定name也不指定type属性，这时将**通过反射机制使用byName**自动注入策略。

    `@Autowired`**只根据type进行注入**，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖`@Qualifier`或`@Primary`注解一起来修饰。

- 例如：有2个Cook接口的实现类：CookTomato和CookPatato

  ```java
  public class CookTomato implements Cook {
  }
  
  public class CookPatato implements Cook {
  }
  ```

  定义类CookController，注入Cook接口

  ```java
  // 方式一：使用@Resource带name属性
  public class CookController {
  	@Resource(name="cookTomato")
  	private Cook cook;
  }
  
  // 方式二：使用@Autowired和@Qualifier
  public class CookController {
  	@Autowired
      @Qualifier("cookTomato")
  	private Cook cook;
  }
  ```

- 总结

  - `@Autowired`只包含一个参数：**required**，表示是否开启自动准入，默认是true。而`@Resource`包含七个参数，其中最重要的两个参数是：**name 和 type**。

  - `@Autowired`如果要使用byName，需要使用`@Qualifier`一起配合。

  - `@Autowired`能够用在：**构造器、方法、参数、成员变量和注解**上，而`@Resource`能用在：**类、成员变量和方法**上。

  - 二者装配顺序

    - @Autowired

      ![@Autowired装配顺序](常用注解.assets/@Autowired.png)

    - @Resource

      ![@Resource装配顺序](常用注解.assets/@Resource.png)

## `@Qualifier`和`@Primary`

- 参考链接：[W3Cschool](https://www.w3cschool.cn/wkspring/knqr1mm2.html)、[掘金](https://juejin.cn/post/6844904035342893063)

- `@Qualifier`：当创建**多个**具有相同类型的 bean 时，并且想要用一个属性只为它们**其中一个**进行装配，在这种情况下，你可以通过使用 `@Qualifier` 和 `@Autowired` 来指定哪一个真正的 bean 将会被装配以消除歧义。

  ```java
  public class Profile {
     @Autowired
     @Qualifier("student1")
     private Student student;
  }
  ```

- `@Primary`：用来在发生依赖注入歧义时决定要注入哪个 bean。当存在多个相同类型的 bean 时，此注解定义了**首选项**。

  ```java
  @Bean
  public Employee tomEmployee() {
      return new Employee("Tom");
  }
  
  @Bean
  @Primary
  public Employee johnEmployee() {
      return new Employee("john");
  }
  ```

- 总的来说，`@Primary` 定义了默认值，而 `@Qualifier` 则非常具体。值得注意的是，如果 `@Qualifier` 和 `@Primary` 注释**都存在**，那么 `@Qualifier` 注释将具有**优先权**。

## `@RequestMapping`和`@GetMapping`

- 参考链接：[CSDN](https://blog.csdn.net/you18131371836/article/details/108198288)、[知乎](https://zhuanlan.zhihu.com/p/79582009)

- `@RequestMapping`作用是映射URL路径，将HTTP请求地址映射到控制器(Controller)类的处理方法上。`@RequestMapping`可以定义在控制器类上，也可以定义在类方法上：

  - 定义类上：将HTTP请求映射到该控制器上，规定初步的请求映射地址，相当于**请求地址的父路径**。

  - 定义类方法上：进一步指定HTTP请求到控制器处理方法的映射关系。如果在控制器类上没有定义`@RequestMapping`，则直接将请求地址映射到处理方法上。

  - ```java
    @RequestMapping(value = "/api/v1/rabbit")
    public class RabbitMqController {
        @RequestMapping(value = "/addexchange")
        public Object addExchange(@RequestBody RabbitExchange rabbitExchange) {
            return null;
        }
    }
    ```

- `@GetMapping`用于处理HTTP GET请求，并将请求映射到**具体的处理方法**中。它是一个**组合注解**，相当于是`@RequestMapping(method=RequestMethod.GET)`的快捷方式。

  ```java
  public class UserController {
      @GetMapping("/users")
      public List<User> findAllUser() {
          List<User> users = userService.findAll();
          return users;
      }
  }
  ```

## `@PathVariable`和`@RequestParam`

- 参考链接：[Stack Overflow](https://stackoverflow.com/questions/13715811/requestparam-vs-pathvariable)

- `@PathVariable`是从URL里获取一些占位符

- `@Requestparam`是从URL获取参数

- 相同点：二者都可以用于在Controller层接收前端传递的数据

- 不同点：二者的应用场景不同

  - `@PathVariable`是获取**请求路径里面**的参数
  - `@RequestParam`是获取**请求里面携带**的参数

- 应用示例

  URL：`http://localhost:8080/MyApp/user/1234/invoices?date=12-05-2013`

  ```java
  @RequestMapping(value="/user/{userId}/invoices", method = RequestMethod.GET)
  public List<Invoice> listUsersInvoices(
      @PathVariable("userId")
      int user,
      @RequestParam(value = "date", required = false)
      Date dateOrNull)
  ```

## `@Transactional`

参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-transaction.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1)

### 前言：关于事务

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

需要格外注意的是：**数据库引擎是否支持事务是事务能否生效的关键**。比如常用的 MySQL 数据库默认使用**支持事务的 `innodb`引擎**。但是，如果把数据库引擎变为 `myisam`，那么程序也就不再支持事务了！

#### 事务特性（ACID）

- **原子性（Atomicity）：** 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，**事务不可分割、不可约简**。
- **一致性（Consistency）：** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的**预设约束、触发器、级联回滚**等。
- **隔离性（Isolation）：** 数据库**允许多个并发事务同时对其数据进行读写和修改**的能力，隔离性可以**防止多个事务并发执行时由于交叉执行而导致数据的不一致**。事务隔离分为不同级别，包括**未提交读**（Read uncommitted）、**提交读**（read committed）、**可重复读**（repeatable read）和**串行化**（Serializable）。
- **持久性（Durability）:** 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

#### 补充：MySQL如何保证原子性？

如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**。

在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。

如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，**回滚日志会先于数据持久化到磁盘上**。这样就保证了**即使遇到数据库突然宕机**等情况，当用户再次启动数据库的时候，**数据库还能够通过查询回滚日志来回滚**将之前未完成的事务

### Spring支持两种方式的事务管理

#### 编程式事务管理

通过 **`TransactionTemplate`**或者**`TransactionManager`**手动管理事务，实际应用中很少使用。

前者示例代码：

```java
@Autowired
private TransactionTemplate transactionTemplate;
public void testTransaction() {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
            try {
                // ....  业务代码
            } catch (Exception e){
                //回滚
                transactionStatus.setRollbackOnly();
            }
        }
    });
}
```

后者示例代码：

```java
@Autowired
private PlatformTransactionManager transactionManager;
public void testTransaction() {
    TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    try {
        // ....  业务代码
        transactionManager.commit(status);
    } catch (Exception e) {
        transactionManager.rollback(status);
    }
}
```

#### 声明式事务管理

推荐使用（**代码侵入性最小**），实际是通过 **AOP** 实现（基于`@Transactional` 的全注解方式使用最多）。

使用 `@Transactional`注解进行事务管理的示例代码如下：

```java
@Transactional(propagation = Propagation.REQUIRED)
public void aMethod {
  //do something
  B b = new B();
  C c = new C();
  b.bMethod();
  c.cMethod();
}
```

### Spring事务管理接口介绍

Spring 框架中，事务管理相关最重要的 3 个接口：

- **`PlatformTransactionManager`**：平台事务管理器，Spring事务策略的核心。
- **`TransactionDefinition`**：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。
- **`TransactionStatus`**：事务运行状态

可以把 **`PlatformTransactionManager`** 接口看作是**事务上层的管理者**，而 **`TransactionDefinition`** 和 **`TransactionStatus`** 这两个接口可以看作是**事务的描述**。

**`PlatformTransactionManager`** 会根据 **`TransactionDefinition`** 的**定义**（比如事务超时时间、隔离级别、传播行为等）来进行事务管理 ，而 **`TransactionStatus`** 接口则提供了一些**方法**来获取事务相应的状态比如是否新事务、是否可以回滚等等。

### 事务属性详解

实际业务开发中，大家一般都是使用 **`@Transactional`** 注解来开启事务。

事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。包含了 5 个方面：**隔离级别**、**传播行为**、**回滚规则**、**是否只读**和**事务超时**。

#### 事务传播行为

**事务传播行为是为了解决业务层方法之间互相调用的事务问题**。

例子：在 A 类的`aMethod()`方法中调用了 B 类的 `bMethod()` 方法。这个时候就涉及到业务层方法之间**互相调用的事务问题**。如果 `bMethod()`如果发生异常需要回滚，如何配置事务传播行为才能让 `aMethod()`也跟着回滚呢？

```java
@Service
Class A {
    @Autowired
    B b;
    @Transactional(propagation = Propagation.xxx)
    public void aMethod {
        //do something
        b.bMethod();
    }
}

@Service
Class B {
    @Transactional(propagation = Propagation.xxx)
    public void bMethod {
       //do something
    }
}
```

在`TransactionDefinition`定义中包括了如下几个表示传播行为的常量：

```java
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    ......
}
```

为了方便使用，Spring 相应地定义了一个枚举类：`Propagation`

```java
public enum Propagation {
    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),
    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),
    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),
    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),
    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),
    NEVER(TransactionDefinition.PROPAGATION_NEVER),
    NESTED(TransactionDefinition.PROPAGATION_NESTED);
    
    private final int value;
    
    Propagation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }
}
```

**正确的事务传播行为可能的值如下** ：

1. **`TransactionDefinition.PROPAGATION_REQUIRED`**

   使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解**默认**使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：

   - 如果**外部方法没有开启事务**的话，`Propagation.REQUIRED`修饰的内部方法会**新开启自己的事务**，且开启的事务**相互独立**，互不干扰。

   
   

