# Java中常用的注解

## `@Component`、`@Controller`、`@Repository`、`@Service`

- 参考链接：[知乎](https://zhuanlan.zhihu.com/p/137507309)、[Stack Overflow](https://stackoverflow.com/questions/6827752/whats-the-difference-between-component-repository-service-annotations-in)
- `@Component`：任何**Spring**管理组件的通用原型。
- `@Repository`：作用于**持久层**，主要用于数据库相关操作。
- `@Service`：作用于**服务层**，主要涉及复杂业务逻辑。
- `@Controller`：作用于**表现层**（SpringMVC），主要用于接收用户请求并调用服务层返回数据给前端页面。

## `@Controller`和`@RestController`

- 参考链接：[微信公众号](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485544&idx=1&sn=3cc95b88979e28fe3bfe539eb421c6d8&chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&token=1725092312&lang=zh_CN#rd)

- 单独使用 `@Controller` 不加 `@ResponseBody`的话一般使用在要返回一个**视图**的情况，这种情况属于比较传统的SpringMVC 的应用，对应于前后端不分离的情况。

  ![SpringMVC传统工作流程](常用注解.assets/640.png)

- `@RestController`只返回**对象**，对象数据直接以**JSON**或**XML**形式写入HTTP响应体中，这种情况属于**RESTful Web**服务，目前开发最常用的情况（前后端分离）。

  ![SpringMVC+@RestController](常用注解.assets/1451.png)

- `@RestController`=`@Controller`+`@RespnseBody`。其中`@ResponseBody`的作用是将`@Controller`的方法的返回对象通过适当的转换器转换为指定的格式后，写入到HTTP响应体中，通常用来返回Json或XML数据。

  ![Spring3.xMVC RESTful Web 服务工作流程](常用注解.assets/123.png)

## `@Value`

- 参考链接：[CSDN](https://blog.csdn.net/wangshuminjava/article/details/81476028)

- 使用`@Value`读取配置信息，有两种方式：

    - `${}`方式：属于**属性占位符**方式
    
      ```java
      @Value("${jdbc.url}")
      private String url;
      ```
    
      对应的配置方式
    
      ```xml
      <!--基于占位符方式 配置单个properties -->
      <context:property-placeholder location="conf/jdbc.properties"/>
      
      <!--基于占位符方式 配置多个properties -->
      <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
      	<property name="location" value="conf/jdbc.properties"/>
      </bean>
      ```
    
    - `#{}`方式：属于**SpEL表达式**方式
    
      ```java
      @Value("#{configProperties['jdbc.url']}")
      private String url;
      ```
    
      对应的配置方式
    
      ```xml
      <!--基于SpEL表达式 配置多个properties id值为configProperties 提供java代码中使用 -->
      <bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
          <property name="locations">
              <list>
                  <value>classpath:/conf/jdbc.properties</value>
              </list>
          </property>
      </bean>
      
      <!--基于SpEL表达式 配置单个properties -->
      <util:properties id="configProperties" location="classpath:conf/jdbc.properties"/>
      ```
      
## `@Component`和`@Bean`

- 参考链接：[Stack Overflow](https://stackoverflow.com/questions/10604298/spring-component-versus-bean)

- 作用对象不同：`@Component`作用于类，`@Bean`作用于方法。

- `@Component`通过类路径扫描自动检测和自动装配到Spring容器中。该类和创建的bean之间有一个**隐式**的一对一映射（即每个类对应一个bean）。这种方法对连接的控制非常有限，因为它纯粹是**声明性**的。

- `@Bean`用于**显式**声明单个bean，而不是让Spring自动声明。它将bean的声明与类定义解耦，并允许按照自己选择的方式创建和配置bean，所以它的**自定义性**更强。所以需要引用第三方库中的类需要装配到 Spring 容器时，只能通过 `@Bean` 来实现。

  ```java
  @Bean
  public OneService getService(status) {
      case (status) {
          when 1:
          return new serviceImpl1();
          when 2:
          return new serviceImpl2();
          when 3:
          return new serviceImpl3();
      }
  }
  ```

## `@Required`

- 参考链接：[W3Cschool](https://www.w3cschool.cn/wkspring/9sle1mmh.html)

- `@Required` 注解应用于 bean 属性的 **setter 方法**，它表明受影响的 **bean 属性在配置时必须放在 XML 配置文件中**，否则容器就会抛出一个 BeanInitializationException 异常，如下所示：

  Student.java文件：

  ```java
  import org.springframework.beans.factory.annotation.Required;
  public class Student {
     private Integer age;
     private String name;
     @Required
     public void setAge(Integer age) {
        this.age = age;
     }
     public Integer getAge() {
        return age;
     }
     @Required
     public void setName(String name) {
        this.name = name;
     }
     public String getName() {
        return name;
     }
  }
  ```

  Beans.xml文件：这里没有对属性age进行注解，所以会抛出异常。

  ```xml
  <context:annotation-config/>
  
  <!-- Definition for student bean -->
  <bean id="student" class="com.tutorialspoint.Student">
      <property name="name"  value="Zara" />
      <!-- try without passing age and check the result -->
      <!-- property name="age"  value="11"-->
  </bean>
  ```

## `@Autowired`和`@Resource`

- 参考链接：[掘金](https://juejin.cn/post/7022507865701089317)

- 相同点：`@Resource`和`@Autowired`都可以作为注入属性的修饰，在接口**仅有单一实现类**时，两个注解的修饰效果相同，可以互相替换，不影响使用。

- 不同点

  - `@Resource`是JDK原生的注解，`@Autowired`是Spring2.5 引入的注解

  - `@Resource`有两个属性**name**和**type**。Spring将`@Resource`注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用**name属性，则使用byName**的自动注入策略，而使用**type属性时则使用byType**自动注入策略。如果既不指定name也不指定type属性，这时将**通过反射机制使用byName**自动注入策略。

    `@Autowired`**只根据type进行注入**，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖`@Qualifier`或`@Primary`注解一起来修饰。

- 例如：有2个Cook接口的实现类：CookTomato和CookPatato

  ```java
  public class CookTomato implements Cook {
  }
  
  public class CookPatato implements Cook {
  }
  ```

  定义类CookController，注入Cook接口

  ```java
  // 方式一：使用@Resource带name属性
  public class CookController {
  	@Resource(name="cookTomato")
  	private Cook cook;
  }
  
  // 方式二：使用@Autowired和@Qualifier
  public class CookController {
  	@Autowired
      @Qualifier("cookTomato")
  	private Cook cook;
  }
  ```

- 总结

  - `@Autowired`只包含一个参数：**required**，表示是否开启自动准入，默认是true。而`@Resource`包含七个参数，其中最重要的两个参数是：**name 和 type**。

  - `@Autowired`如果要使用byName，需要使用`@Qualifier`一起配合。

  - `@Autowired`能够用在：**构造器、方法、参数、成员变量和注解**上，而`@Resource`能用在：**类、成员变量和方法**上。

  - 二者装配顺序

    - @Autowired

      ![@Autowired装配顺序](常用注解.assets/@Autowired.png)

    - @Resource

      ![@Resource装配顺序](常用注解.assets/@Resource.png)

## `@Qualifier`和`@Primary`

- 参考链接：[W3Cschool](https://www.w3cschool.cn/wkspring/knqr1mm2.html)、[掘金](https://juejin.cn/post/6844904035342893063)

- `@Qualifier`：当创建**多个**具有相同类型的 bean 时，并且想要用一个属性只为它们**其中一个**进行装配，在这种情况下，你可以通过使用 `@Qualifier` 和 `@Autowired` 来指定哪一个真正的 bean 将会被装配以消除歧义。

  ```java
  public class Profile {
     @Autowired
     @Qualifier("student1")
     private Student student;
  }
  ```

- `@Primary`：用来在发生依赖注入歧义时决定要注入哪个 bean。当存在多个相同类型的 bean 时，此注解定义了**首选项**。

  ```java
  @Bean
  public Employee tomEmployee() {
      return new Employee("Tom");
  }
  
  @Bean
  @Primary
  public Employee johnEmployee() {
      return new Employee("john");
  }
  ```

- 总的来说，`@Primary` 定义了默认值，而 `@Qualifier` 则非常具体。值得注意的是，如果 `@Qualifier` 和 `@Primary` 注释**都存在**，那么 `@Qualifier` 注释将具有**优先权**。

## `@RequestMapping`和`@GetMapping`

- 参考链接：[CSDN]()

- `@RequestMapping`作用是映射URL路径，将HTTP请求地址映射到控制器(Controller)类的处理方法上。`@RequestMapping`可以定义在控制器类上，也可以定义在类方法上：

  - 定义类上：将HTTP请求映射到该控制器上，规定初步的请求映射地址，相当于**请求地址的父路径**。

  - 定义类方法上：进一步指定HTTP请求到控制器处理方法的映射关系。如果在控制器类上没有定义`@RequestMapping`，则直接将请求地址映射到处理方法上。

  - ```java
    @RequestMapping(value = "/api/v1/rabbit")
    public class RabbitMqController {
        @RequestMapping(value = "/addexchange")
        public Object addExchange(@RequestBody RabbitExchange rabbitExchange) {
            return null;
        }
    }
    ```

- `@GetMapping`用于处理HTTP GET请求，并将请求映射到**具体的处理方法**中。它是一个**组合注解**，相当于是`@RequestMapping(method=RequestMethod.GET)`的快捷方式。

