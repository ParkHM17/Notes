# Spring & SpringBoot常用注解

## 一、`@SpringBootApplication`:boat:

> 参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html#_1-springbootapplication)

这个注解是SpringBoot项目的基石，创建项目后会默认加在主类上。

```java
@SpringBootApplication
public class SpringSecurityJwtGuideApplication {
      public static void main(java.lang.String[] args) {
        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);
    }
}
```

可以把`@SpringBootApplication`看作是`@Configuration`、`@EnableAutoConfiguration`、`@ComponentScan`的合集。

```java
package org.springframework.boot.autoconfigure;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
   ......
}

package org.springframework.boot;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration {

}
```

根据SpringBoot官网，这三个注解的作用分别是：

- `@Configuration`：允许在Spring上下文中注册额外的bean或导入其他配置类。
- `@EnableAutoConfiguration`：启用SpringBoot的自动配置机制。
- `@ComponentScan`：扫描被`@Component`（`@Repository`，`@Service`，`@Controller`)注解的bean，注解默认会扫描**该类所在的包下所有的类**。

## 二、Spring Bean相关

### 2.1 `@Autowired`:airplane:

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/spring/springboot/springboot-x-hello-anno.html#autowired)

可以对类**成员变量、方法及构造函数**进行标注，完成自动装配的工作。

在默认情况下使用`@Autowired`注解进行自动注入时，Spring容器中匹配的候选Bean数目必须**有且仅有**一个。当找不到一个匹配的Bean时，Spring容器将抛出`BeanCreationException`异常，并指出必须**至少拥有一个**匹配的 Bean。

当不能确定Spring容器中一定拥有某个类的Bean时，可以在需要自动注入该类Bean的地方可以使用`@Autowired(required = false)`，这等于告诉Spring：**尽管找不到匹配Bean也不报错**。

#### 三种注入方式

> 参考链接：[DZone](https://dzone.com/articles/spring-di-patterns-the-good-the-bad-and-the-ugly)、[掘金](https://juejin.cn/post/7021902992706109476)

1. 属性注入（Bad）：在属性上直接使用注解，内部使用**反射**方式实现注入。

   - 优点：代码简洁。
   - 缺点：依赖对象**可能为NULL而导致空指针异常**。

   ```java
   public class MyBean {
      @Autowired
      private AnotherBean anotherBean;
       
   }
   ```

2. Setter注入（Ugly）：Spring3.x中推荐使用的方式，在Set方法上完成对象注入。

   - 优点：选择性注入。
   - 缺点：对象实例化后，**依赖信息依然可以通过Set方法修改**。

   ```java
   public class MyBean {
      private AnotherBean anotherBean;
   
      @Autowired
      public void setAnotherBean(final AnotherBean anotherBean) {
          this.anotherBean = anotherBean;
      }
   
   }
   ```

3. 构造器注入（Good）：Spring4.x中推荐使用的方式，对象以参数的形式传递，在构造函数中完成注入对象的初始化。

   - 优点：**依赖不可变**：使用强制性的显式注入（`final`关键字保证不可变）；**依赖不为空**：在传参时如果参数为NULL则报错，提前避免了空指针异常。
   - 缺点：当需要注入的依赖较多时，构造函数会较为**臃肿**。

   ```java
   public class MyBean {
      private final AnotherBean anotherBean;
   
      @Autowired
      public MyBean(final AnotherBean anotherBean) {
          this.anotherBean = anotherBean;
      }
   
   }
   ```

#### 补充：Spring IoC:airplane:

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/spring/spring-x-framework-ioc.html)

##### 引入

1. Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫**控制反转——Inversion of Control (IoC)**。
2. Spring框架托管创建的Bean放在哪里呢？ 这便是**IoC Container**。
3. Spring框架为了更好让用户配置Bean，必然会引入**不同方式来配置Bean：xml配置、Java配置和注解配置**。
4. Spring框架既然接管了Bean的生成，必然需要**管理整个Bean的生命周期**。
5. 应用程序代码从IoC Container中获取依赖的Bean注入到应用程序中，这个过程叫**依赖注入（Dependency Injection, DI)** 。所以说**控制反转是通过依赖注入实现**的，通俗来说就是**IoC是设计思想，DI是实现方式**。
6. Bean可能互相之间存在依赖（先后顺序问题，或者**循环依赖问题**等）。

##### 如何理解IoC？

###### Spring Bean是什么？

> IoC Container管理的是Spring Bean，那么Spring Bean是什么呢？

Spring里面的Bean类似是定义的一个组件，而这个组件的作用就是为了实现某个功能。这里所定义的Bean就相当于**提供一个更为简便的方法来调用这个组件去实现功能**。

###### IoC是什么？

> IoC不是一种具体的技术，**而是一种设计思想**。在Java开发中，IoC意味着将设计好的对象交给容器控制，而不是传统的在对象内部直接控制。

深入分析：

- 谁控制谁，控制什么？

  传统Java SE程序设计，直接在对象内部通过`new`进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由IoC容器来控制对象的创建。**谁控制谁？当然是IoC容器控制了对象**；**控制什么？那就是主要控制了外部资源获取（不只是对象，还有文件等）**。

- 为何是反转，哪些方面反转了？

  传统应用程序是由程序员在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；**为何是反转？因为由容器查找及注入依赖对象，对象只是被动地接受依赖对象，所以是反转**；**哪些方面反转了？依赖对象的获取被反转了**。

- 图例说明

  传统程序设计下，是主动去创建相关对象然后再组合：

  ![传统创建对象](常用注解.assets/spring-framework-ioc-1.png)

  当有了IoC容器后，不再主动创建对象了：

  ![IoC容器创建对象](常用注解.assets/spring-framework-ioc-2.png)

###### IoC能做什么？

> 它是一个重要的面向对象编程的法则，指导如何设计出**松耦合、更优良**的程序。

传统应用程序都是由程序员在类内部**主动创建依赖对象**，导致类与类之间**高耦合且难于测试**；有了IoC容器后，把**创建和查找依赖对象的控制权交给了容器**，由**容器进行注入组合对象**，所以对象与对象之间是**松散耦合**，这样也方便测试和功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

其实IoC对编程带来的最大改变不是从代码上，而是从**思想**上：发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是**主动**出击。但是在IoC中，应用程序就变成**被动**的了，被动地等待IoC容器来创建并注入它所需要的资源。

IoC很好的体现了面向对象设计法则之一—— **好莱坞法则：“别找我们，我们找你”**，即由IoC容器**帮对象找相应的依赖对象并注入**，而不是由对象主动去找。

###### IoC和DI是什么关系？

> 通俗来说就是**IoC是设计思想，DI是实现方式**。

DI：Dependency Injection，即依赖注入。组件之间依赖关系由容器在运行期决定，形象的说，即**由容器动态地将某个依赖关系注入到组件之中**。依赖注入的目的并非为软件系统带来更多功能，而是**为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台**。通过依赖注入机制，程序员只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源**来自何处，由谁实现**。

深入分析：

- 谁依赖于谁？

  应用程序依赖于IoC容器。

- 为什么需要依赖？

  应用程序需要IoC容器来提供对象需要的外部资源。

- 谁注入谁？

  IoC容器注入应用程序

- 注入了什么？

  注入某个对象所需要的外部资源（包括对象、资源、常量数据等）。

- IoC和DI有什么关系？

  由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC而言，“依赖注入”明确描述了“**被注入对象依赖IoC容器配置依赖对象**”。通俗来说就是**IoC是设计思想，DI是实现方式**。

#### 补充：Spring中Bean的生命周期:airplane:

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#%E9%87%8D%E7%82%B9%EF%BC%9Aspring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)

> Spring只管理单例模式Bean的**完整**生命周期，对于prototype的Bean，Spring创建好并交给使用者之后就不会再管理后续的生命周期。

Spring容器可以管理**singleton作用域Bean**的生命周期，在此作用域下，Spring能够精确地知道该Bean何时被**创建**、何时**初始化完成**以及何时被**销毁**。

而对于prototype作用域的Bean，Spring**只负责创建**。当创建了Bean的实例后，Bean的实例就交给客户端代码管理，Spring容器将不再跟踪其生命周期。每次客户端请求prototype作用域的Bean时，Spring容器都会创建一个新的实例，并且不会管那些被配置成prototype作用域的Bean的生命周期。

了解Spring生命周期的意义就在于，**可以利用Bean在其存活期间的指定时刻完成一些相关操作**。这种时刻可能有很多，但一般情况下，会在Bean被**初始化后和被销毁前**执行一些相关操作。

##### 生命周期流程

> 在Spring中，Bean的生命周期是一个很复杂的执行过程，可以利用Spring提供的方法定制Bean的创建过程。

![Spring中Bean的生命周期流程](常用注解.assets/spring-framework-ioc-source-102.png)

1. 如果`BeanFactoryPostProcessor`和Bean关联，则调用`postProcessBeanFactory()`方法（即**首先尝试从Bean工厂中获取Bean**）；
2. 如果`InstantiationAwareBeanPostProcessor`和Bean关联，则调用`postProcessBeforeInstantiation()`方法；
3. 根据配置情况调用Bean构造方法**实例化（Instantiation）Bean**；
4. 利用依赖注入完成Bean中所有属性值的配置注入；
5. 如果`InstantiationAwareBeanPostProcessor`和Bean关联，则调用`postProcessAfterInstantiation()`方法和`postProcessProperties()`方法；
6. 调用`XXXAware`接口（图中仅给出部分例子）：
   - 第一类接口：
     - 如果Bean实现了`BeanNameAware`接口，则Spring调用Bean的`setBeanName()`方法传入当前Bean的**id**值。（图中示例）
     - 如果Bean实现了`BeanClassLoaderAware`接口，则Spring调用`setBeanClassLoader()`方法传入classLoader的引用。
     - 如果Bean实现了`BeanFactoryAware`接口，则Spring调用`setBeanFactory()`方法传入当前工厂实例的引用。（图中示例）
   - 第二类接口：
     - 如果Bean实现了`EnvironmentAware`接口，则Spring调用`setEnvironment()`方法传入当前Environment实例的引用。
     - 如果Bean实现了`EmbeddedValueResolverAware`接口，则Spring调用`setEmbeddedValueResolver()`方法传入当前StringValueResolver实例的引用。
     - 如果Bean实现了`ApplicationContextAware`接口，则Spring调用`setApplicationContext()`方法传入当前ApplicationContext实例的引用。（图中示例）
   - ……
7. 如果`BeanPostProcessor`和Bean关联，则Spring将调用该接口的预初始化方法`postProcessBeforeInitialzation()`对Bean进行加工操作，此处非常重要，**因为Spring的AOP就是利用它实现的**；
8. 如果Bean实现了`InitializingBean`接口，则Spring将调用`afterPropertiesSet()`方法（或者执行有`@PostConstruct`注解的方法）；
9. 如果在配置文件中通过**`init-method`**属性指定了初始化方法，则调用该初始化方法；
10. 如果`BeanPostProcessor`和Bean关联，则Spring将调用该接口的初始化方法`postProcessAfterInitialization()`方法。此时，**Bean初始化（Initialization）完成**，已经可以被应用系统使用了；
11. 如果在`<bean>`中指定了该Bean的作用范围为**`scope="singleton"`**，则将该Bean放入Spring IoC的**缓存池**中，触发Spring对该Bean的**生命周期管理**；如果在`<bean>`中指定了该Bean的作用范围为`scope="prototype"`，则将该Bean交给调用者，由调用者管理该Bean的生命周期，Spring不再管理该Bean；
12. 如果Bean实现了`DisposableBean`接口，则Spring会调用`destory()`方法将Spring中的Bean销毁（或者执行有`@PreDestroy`注解的方法）；
13. 如果在配置文件中通过**`destory-method`**属性指定了Bean的销毁方法，则Spring将调用该方法对Bean进行销毁。

**Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类**：（需要结合上图）

- **Bean自身的方法**：这个包括了Bean本身调用的方法和通过配置文件中`<bean>`的`init-method`和`destroy-method`指定的方法。
- **Bean级生命周期接口方法**：这个包括了`BeanNameAware`、`BeanFactoryAware`、`ApplicationContextAware`；当然也包括`InitializingBean`和`DiposableBean`这些接口的方法（它们可以被`@PostConstruct`和`@PreDestroy`注解替代）。
- **容器级生命周期接口方法**：这个包括了`InstantiationAwareBeanPostProcessor`和`BeanPostProcessor`这两个接口实现，一般称它们的实现类为**“后处理器”**。
- **工厂后处理器接口方法**：这个包括了`AspectJWeavingEnabler`、`ConfigurationClassPostProcessor`和`CustomAutowireConfigurer`等非常有用的工厂后处理器接口的方法。**工厂后处理器也是容器级的**，在**应用上下文装配配置文件之后立即调用**。

##### 生命周期案例和源码:rainbow:

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#spring-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A1%88%E4%BE%8B)

#### 补充：Spring如何解决循环依赖问题:airplane:

##### 什么是循环依赖？

> 参考链接：[腾讯云](https://cloud.tencent.com/developer/article/1749830)

从字面上来理解就是**A依赖B的同时B也依赖了A**，或者C依赖于自己本身（自依赖），体现到代码层次就是：

```java
@Component
public class A {
 // A中注入了B
 @Autowired
 private B b;
}

@Component
public class A {
 // A中注入了B
 @Autowired
 private B b;
}

// 自己依赖自己
@Component
public class C {
 // C中注入了C
 @Autowired
 private C c;
}
```

##### Spring是如何解决的？

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#%E9%87%8D%E7%82%B9%EF%BC%9Aspring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98)

> Spring只是解决了**单例模式下**属性依赖的循环问题。Spring为了解决单例的循环依赖问题，使用了**三级缓存**。

###### Spring单例模式下的属性依赖

三级缓存：

- **第一级缓存（singletonObjects）**：单例对象缓存池，**已经实例化并且属性赋值**，这里的对象是**成熟对象**。
- **第二级缓存（earlySingletonObjects）**：单例对象缓存池，**已经实例化但尚未属性赋值**，这里的对象是**半成品对象**。
- **第三级缓存（singletonFactories）**：单例工厂的缓存。

```java
/** Cache of singleton objects: bean name --> bean instance */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);
 
/** Cache of early singleton objects: bean name --> bean instance */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);

/** Cache of singleton factories: bean name --> ObjectFactory */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
```

下面是获取单例的过程：

```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
  // Spring首先从singletonObjects（一级缓存）中尝试获取
  Object singletonObject = this.singletonObjects.get(beanName);
  // 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取
  if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
    synchronized (this.singletonObjects) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
          ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
          if (singletonFactory != null) {
            //若是仍是获取不到而且容许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取
              singletonObject = singletonFactory.getObject();
              //若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中
              this.earlySingletonObjects.put(beanName, singletonObject);
              this.singletonFactories.remove(beanName);
          }
        }
    }
  }
  return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```

补充一些方法和参数：

- `isSingletonCurrentlyInCreation()`：**判断当前单例Bean是否正在建立中，也就是有没有初始化完成**（好比A的构造器依赖了B对象，因此得先去建立B对象，或者在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态）。
- `allowEarlyReference` ：**是否容许从singletonFactories中经过getObject拿到对象**。

分析`getSingleton()`的整个过程：Spring首先从**一级缓存singletonObjects**中获取，若是获取不到而且对象正在建立中，就再从**二级缓存earlySingletonObjects**中获取，若仍是获取不到且容许singletonFactories经过`getObject()`获取，就从**三级缓存singletonFactory.`getObject()`（三级缓存）**获取，若是获取到了则从三级缓存移动到二级缓存。

从上面的分析可以知道，Spring解决循环依赖的诀窍就在于**singletonFactories这个三级cache**。这个cache的类型是ObjectFactory，定义如下：

```java
public interface ObjectFactory<T> {
    T getObject() throws BeansException;
}
```

在Bean建立过程当中，有两处比较重要的匿名内部类实现了该接口。一处是Spring利用其建立Bean的时候，另外一处如下：

```java
addSingletonFactory(beanName, new ObjectFactory<Object>() {
   @Override   public Object getObject() throws BeansException {
      return getEarlyBeanReference(beanName, mbd, bean);
   }});
```

此处就是**解决循环依赖的关键**，这段代码发生在createBeanInstance以后，也就是说单例对象此时已经被建立出来。**这个对象已经被生产出来了，虽然还不完美（尚未进行初始化的第二步和第三步），可是已经能被认出来了（根据对象引用能定位到堆中的对象）**，因此Spring此时将这个对象提早曝光出来使用。

好比“**A对象Setter依赖B对象，B对象Setter依赖A对象**”：A首先完成了初始化的第一步，而且将本身提早曝光到**singletonFactories**中，此时进行初始化的第二步，发现本身依赖对象B，此时就尝试获取B，发现B**尚未被create**，因此走create流程，B在初始化第一步的时候发现本身依赖了对象A，因而尝试获取A，**尝试一级缓存singletonObjects**（确定没有，因为A还没彻底初始化），**尝试二级缓存earlySingletonObjects**（也没有），**尝试三级缓存singletonFactories**，因为A经过ObjectFactory将本身提早曝光了，因此**B可以经过ObjectFactory.`getObject()`拿到A对象（半成品）**，B拿到A对象后顺利完成了初始化阶段一、二、三，**彻底初始化以后将本身放入到一级缓存singletonObjects中**。此时返回A中，**A此时能拿到B的对象顺利完成本身的初始化阶段二、三**，最终**A也完成了初始化进了一级缓存singletonObjects中**。

###### Spring为何不能解决非单例之外的循环依赖？

- Spring为什么不能解决构造器的循环依赖？

  构造器注入形成的循环依赖：也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。

  Spring解决循环依赖主要是依赖三级缓存，但是**在调用构造方法之前还未将其放入三级缓存之中**，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。

  - 这里有一点需要说明：**如果beanA注入B的方式为Setter而beanB注入A的方式为构造器，这样的循环依赖是可以解决的。**

    > 参考链接：[腾讯云](https://cloud.tencent.com/developer/article/1749830)、[CSDN](https://blog.csdn.net/u010013573/article/details/90573901)

    原因在于：**Spring在创建Bean时默认会根据自然排序进行创建**，beanA（**主Bean**）会先于beanB进行创建。所以beanA可以成功地将自己放入三级缓存中。

    总结：**只要主Bean注入依赖的方式不为构造器就可以解决循环依赖**。

- Spring为什么不能解决prototype作用域循环依赖？

  因为Spring**不会缓存prototype作用域的Bean**。

- Spring为什么不能解决多例的循环依赖？

  多实例Bean是每调用一次getBean都会执行一次构造方法并且给属性赋值，**根本没有三级缓存**，因此不能解决循环依赖。

###### 其他循环依赖如何解决？

- **生成代理对象产生的循环依赖**

  这类循环依赖问题解决方法很多，主要有：

  1. 使用`@Lazy`注解，延迟加载。
  2. 使用`@DependsOn`注解，指定加载先后关系。
  3. 修改文件名称，改变循环依赖类的加载顺序。

- **使用`@DependsOn`产生的循环依赖**

  这类循环依赖问题要找到`@DependsOn`注解循环依赖的地方，迫使它不循环依赖就可以解决问题。

- **多例循环依赖**

  这类循环依赖问题可以通过把Bean改成单例的方法解决。

- **构造器循环依赖**

  这类循环依赖问题可以通过使用`@Lazy`注解解决。

#### 与`@Resource`比较:airplane:

> 参考链接：[掘金](https://juejin.cn/post/7022507865701089317)、[Stack Overflow](https://stackoverflow.com/questions/4093504/resource-vs-autowired)

- 相同点：`@Resource`和`@Autowired`都可以作为注入属性的注解，在接口**仅有单一实现类**时，两个注解的修饰效果相同，可以互相替换，不影响使用。

- 不同点

  - `@Resource`是JDK原生的注解，`@Autowired`是Spring `v2.5`引入的注解。

  - `@Resource`有两个属性：**`name`**和**`type`**。Spring将`@Resource`的`name`属性解析为Bean的名字，而`type`属性则解析Bbean的类型。如果使用**`name`属性，则使用byName**的自动注入策略，而使用**`type`属性时则使用byType**的自动注入策略。如果既不指定`name`也不指定`type`属性，这时将**通过反射机制使用byName**的自动注入策略。

    `@Autowired`**只根据类型进行注入**，不会去匹配名字。如果涉及到**byType**无法辨别的对象时，需要依赖`@Qualifier`或`@Primary`注解一起来修饰。

- 例如：有2个`Cook`接口的实现类：`CookTomato`和`CookPatato`：

  ```java
  public class CookTomato implements Cook {
  }
  
  public class CookPatato implements Cook {
  }
  ```

  定义类`CookController.java`，注入`Cook`接口：

  ```java
  // 方式一：使用@Resource带name属性
  public class CookController {
  	@Resource(name="cookTomato")
  	private Cook cook;
  }
  
  // 方式二：使用@Autowired和@Qualifier
  public class CookController {
  	@Autowired
      @Qualifier("cookTomato")
  	private Cook cook;
  }
  ```

- 总结

  - `@Autowired`只包含一个参数：**`required`**，表示是否开启自动准入，默认是**true**。而`@Resource`包含七个参数，其中最重要的两个参数是：**`name`**和**`type`**。

  - `@Autowired`如果要使用**byName**，需要配合使用`@Qualifier`。

  - 二者装配顺序：

    - `@Autowired`顺序：

      ![@Autowired装配顺序](常用注解.assets/@Autowired.png)

    - `@Resource`顺序：

      ![@Resource装配顺序](常用注解.assets/@Resource.png)



### 2.2 `@Component`、`@Controller`、`@Repository`、`@Service`:airplane:

> 参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html)、[Stack Overflow](https://stackoverflow.com/questions/6827752/whats-the-difference-between-component-repository-service-annotations-in)

- `@Component`：任何**Spring**管理组件的通用原型。
- `@Repository`：作用于**持久层**，主要用于数据库相关操作。
- `@Service`：作用于**服务层**，主要涉及复杂业务逻辑。
- `@Controller`：作用于**表现层**（SpringMVC），主要用于接收用户请求并调用服务层返回数据给前端页面。

### 2.3 `@RestController`和`@Controller`:boat:

> 参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html#_2-spring-bean-%E7%9B%B8%E5%85%B3)、[微信公众号](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485544&idx=1&sn=3cc95b88979e28fe3bfe539eb421c6d8&chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&token=1725092312&lang=zh_CN#rd)

`@RestController`=`@Controller`+`@RespnseBody`。其中`@ResponseBody`的作用是将`@Controller`的方法的返回对象**通过适当的转换器转换为指定的格式后**写入到HTTP响应体中，通常用来返回**Json**或**XML**数据。

![Spring3.xMVC RESTful Web 服务工作流程](常用注解.assets/3.png)

`@RestController`只返回**对象**，对象数据直接以**JSON**或**XML**形式写入HTTP响应体中，这种情况属于**RESTful Web**服务，目前开发最常用的情况（前后端分离）。

![SpringMVC+@RestController](常用注解.assets/2.png)

单独使用`@Controller`不加`@ResponseBody`的话**一般使用在要返回一个视图的情况**，这种情况属于比较传统的SpringMVC的应用，对应于前后端不分离的情况。

![SpringMVC传统工作流程](常用注解.assets/1.png)

### 2.4 `@Scope`:boat:

> 参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html#_2-spring-bean-%E7%9B%B8%E5%85%B3)

声明Spring Bean的作用域，使用方法如下：

```java
@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}
```

**四种常见的Spring Bean的作用域：**

- `singleton`：**唯一**Bean实例，Spring中的Bean默认都是**单例**的。
- `prototype`：**每次请求都会创建一个新的Bean实例**。
- `request`：**每一次HTTP请求都会产生一个新的Bean**，该Bean仅在当前HTTP Request内有效。
- `session`：**每一个HTTP Session会产生一个新的Bean**，该Bean仅在当前HTTP Session内有效。

### 2.5 `@Configuration`:boat:

> 参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html#_2-spring-bean-%E7%9B%B8%E5%85%B3)

一般用来声明配置类，可以使用`@Component`注解替代，不过使用`@Configuration`注解声明配置类更加语义化。

```java
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
```

## 三、处理常见的HTTP请求

> 参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html#_3-%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84-http-%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B)

**5种常见的请求类型：**

- **GET**：请求从服务器获取特定资源。例子：`GET /users`（获取所有学生）。

- **POST**：在服务器上创建一个新的资源。例子：`POST /users`（创建学生）。
- **PUT**：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：`PUT /users/12`（更新编号为12的学生）。
- **DELETE**：从服务器删除特定的资源。举个例子：`DELETE /users/12`（删除编号为12的学生）。
- **PATCH**：更新服务器上的资源（客户端提供更改的属性，可以看成是部分更新），使用的比较少。

### 3.1 GET请求:boat:

```java
@GetMapping("/users")
// 等价于 @RequestMapping(value="/users",method=RequestMethod.GET)
public ResponseEntity<List<User>> getAllUsers() {
 return userRepository.findAll();
}
```

### 3.2 POST请求:boat:

```java
@PostMapping("/users")
// 等价于 @RequestMapping(value="/users",method=RequestMethod.POST)
public ResponseEntity<User> createUser(@Valid @RequestBody UserCreateRequest userCreateRequest) {
 return userRespository.save(userCreateRequest);
}
```

### 3.3 PUT请求:boat:

```java
@PutMapping("/users/{userId}")
// 等价于 @RequestMapping(value="/users/{userId}",method=RequestMethod.PUT)
public ResponseEntity<User> updateUser(@PathVariable(value = "userId") Long userId,
  @Valid @RequestBody UserUpdateRequest userUpdateRequest) {
  ......
}
```

### 3.4 DELETE请求:boat:

```java
@DeleteMapping("/users/{userId}")
// 等价于 @RequestMapping(value="/users/{userId}",method=RequestMethod.DELETE)
public ResponseEntity deleteUser(@PathVariable(value = "userId") Long userId){
  ......
}
```

### 3.5 PATCH请求:boat:

```java
@PatchMapping("/profile")
// 在实际项目中，都是PUT不够用了之后才用PATCH请求去更新数据
public ResponseEntity updateStudent(@RequestBody StudentUpdateRequest studentUpdateRequest) {
    studentRepository.updateDetail(studentUpdateRequest);
    return ResponseEntity.ok().build();
}
```

### 补充：`@RequestMapping`:airplane:



## 四、前后端传值

### 4.1 `@PathVariable`和`@RequestParam`:airplane:

> 参考链接：[Stack Overflow](https://stackoverflow.com/questions/13715811/requestparam-vs-pathvariable)

`@PathVariable`是从URL里获取一些占位符。而`@Requestparam`是从URL获取参数。

- 相同点：二者都可以用于在**Controller层接收前端传递的数据**。

- 不同点：二者的**应用场景不同**：

  - `@PathVariable`是获取**请求路径里面**的参数
  - `@RequestParam`是获取**请求里面携带**的参数

应用示例：

假如URL为：”http://localhost:8080/MyApp/user/1234/invoices?date=12-05-2013“

```java
@RequestMapping(value="/user/{userId}/invoices", method = RequestMethod.GET)
public List<Invoice> listUsersInvoices(
    @PathVariable("userId")
    int user,
    @RequestParam(value = "date", required = false)
    Date dateOrNull)
```

获取到的数据为：`user=1234, dateOrNull=12-05-2013`。

### 4.2 `@RequestBody`:boat:

> 参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html#_4-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC)











## `@Value`:airplane:

- 参考链接：[CSDN](https://blog.csdn.net/wangshuminjava/article/details/81476028)

- 使用`@Value`读取配置信息，有两种方式：

    - `${}`方式：属于**属性占位符**方式
    
      ```java
      @Value("${jdbc.url}")
      private String url;
      ```
    
      对应的配置方式
    
      ```xml
      <!--基于占位符方式 配置单个properties -->
      <context:property-placeholder location="conf/jdbc.properties"/>
      
      <!--基于占位符方式 配置多个properties -->
      <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer">
      	<property name="location" value="conf/jdbc.properties"/>
      </bean>
      ```
    
    - `#{}`方式：属于**SpEL表达式**方式
    
      ```java
      @Value("#{configProperties['jdbc.url']}")
      private String url;
      ```
    
      对应的配置方式
    
      ```xml
      <!--基于SpEL表达式 配置多个properties id值为configProperties 提供java代码中使用 -->
      <bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
          <property name="locations">
              <list>
                  <value>classpath:/conf/jdbc.properties</value>
              </list>
          </property>
      </bean>
      
      <!--基于SpEL表达式 配置单个properties -->
      <util:properties id="configProperties" location="classpath:conf/jdbc.properties"/>
      ```
      
## `@Component`和`@Bean`:airplane:

- 参考链接：[Stack Overflow](https://stackoverflow.com/questions/10604298/spring-component-versus-bean)

- 作用对象不同：`@Component`作用于类，`@Bean`作用于方法。

- `@Component`通过类路径扫描自动检测和自动装配到Spring容器中。该类和创建的bean之间有一个**隐式**的一对一映射（即每个类对应一个bean）。这种方法对连接的控制非常有限，因为它纯粹是**声明性**的。

- `@Bean`用于**显式**声明单个bean，而不是让Spring自动声明。它将bean的声明与类定义解耦，并允许按照自己选择的方式创建和配置bean，所以它的**自定义性**更强。所以需要引用第三方库中的类需要装配到 Spring 容器时，只能通过 `@Bean` 来实现。

  ```java
  @Bean
  public OneService getService(status) {
      case (status) {
          when 1:
          return new serviceImpl1();
          when 2:
          return new serviceImpl2();
          when 3:
          return new serviceImpl3();
      }
  }
  ```

## `@Required`:airplane:

- 参考链接：[W3Cschool](https://www.w3cschool.cn/wkspring/9sle1mmh.html)

- `@Required` 注解应用于 bean 属性的 **setter 方法**，它表明受影响的 **bean 属性在配置时必须放在 XML 配置文件中**，否则容器就会抛出一个 BeanInitializationException 异常，如下所示：

  Student.java文件：

  ```java
  import org.springframework.beans.factory.annotation.Required;
  public class Student {
     private Integer age;
     private String name;
     @Required
     public void setAge(Integer age) {
        this.age = age;
     }
     public Integer getAge() {
        return age;
     }
     @Required
     public void setName(String name) {
        this.name = name;
     }
     public String getName() {
        return name;
     }
  }
  ```

  Beans.xml文件：这里没有对属性age进行注解，所以会抛出异常。

  ```xml
  <context:annotation-config/>
  
  <!-- Definition for student bean -->
  <bean id="student" class="com.tutorialspoint.Student">
      <property name="name"  value="Zara" />
      <!-- try without passing age and check the result -->
      <!-- property name="age"  value="11"-->
  </bean>
  ```

## `@Qualifier`和`@Primary`:airplane:

- 参考链接：[W3Cschool](https://www.w3cschool.cn/wkspring/knqr1mm2.html)、[掘金](https://juejin.cn/post/6844904035342893063)

- `@Qualifier`：当创建**多个**具有相同类型的 bean 时，并且想要用一个属性只为它们**其中一个**进行装配，在这种情况下，你可以通过使用 `@Qualifier` 和 `@Autowired` 来指定哪一个真正的 bean 将会被装配以消除歧义。

  ```java
  public class Profile {
     @Autowired
     @Qualifier("student1")
     private Student student;
  }
  ```

- `@Primary`：用来在发生依赖注入歧义时决定要注入哪个 bean。当存在多个相同类型的 bean 时，此注解定义了**首选项**。

  ```java
  @Bean
  public Employee tomEmployee() {
      return new Employee("Tom");
  }
  
  @Bean
  @Primary
  public Employee johnEmployee() {
      return new Employee("john");
  }
  ```

- 总的来说，`@Primary` 定义了默认值，而 `@Qualifier` 则非常具体。值得注意的是，如果 `@Qualifier` 和 `@Primary` 注释**都存在**，那么 `@Qualifier` 注释将具有**优先权**。

## `@RequestMapping`和`@GetMapping`:airplane:

- 参考链接：[CSDN](https://blog.csdn.net/you18131371836/article/details/108198288)、[知乎](https://zhuanlan.zhihu.com/p/79582009)

- `@RequestMapping`作用是映射URL路径，将HTTP请求地址映射到控制器(Controller)类的处理方法上。`@RequestMapping`可以定义在控制器类上，也可以定义在类方法上：

  - 定义类上：将HTTP请求映射到该控制器上，规定初步的请求映射地址，相当于**请求地址的父路径**。

  - 定义类方法上：进一步指定HTTP请求到控制器处理方法的映射关系。如果在控制器类上没有定义`@RequestMapping`，则直接将请求地址映射到处理方法上。

  - ```java
    @RequestMapping(value = "/api/v1/rabbit")
    public class RabbitMqController {
        @RequestMapping(value = "/addexchange")
        public Object addExchange(@RequestBody RabbitExchange rabbitExchange) {
            return null;
        }
    }
    ```

- `@GetMapping`用于处理HTTP GET请求，并将请求映射到**具体的处理方法**中。它是一个**组合注解**，相当于是`@RequestMapping(method=RequestMethod.GET)`的快捷方式。

  ```java
  public class UserController {
      @GetMapping("/users")
      public List<User> findAllUser() {
          List<User> users = userService.findAll();
          return users;
      }
  }
  ```



## `@Transactional`:rocket:

参考链接：[JavaGuide](https://javaguide.cn/system-design/framework/spring/spring-transaction.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1)、[掘金](https://juejin.cn/post/6844904096747503629)

### 前言：关于事务

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

需要格外注意的是：**数据库引擎是否支持事务是事务能否生效的关键**。比如常用的 MySQL 数据库默认使用**支持事务的 `innodb`引擎**。但是，如果把数据库引擎变为 `myisam`，那么程序也就不再支持事务了！

#### 事务特性（ACID）

- **原子性（Atomicity）：** 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，**事务不可分割、不可约简**。
- **一致性（Consistency）：** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的**预设约束、触发器、级联回滚**等。
- **隔离性（Isolation）：** 数据库**允许多个并发事务同时对其数据进行读写和修改**的能力，隔离性可以**防止多个事务并发执行时由于交叉执行而导致数据的不一致**。事务隔离分为不同级别，包括**未提交读**（Read uncommitted）、**提交读**（read committed）、**可重复读**（repeatable read）和**串行化**（Serializable）。
- **持久性（Durability）:** 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

#### 补充：MySQL如何保证原子性？

如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**。

在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。

如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，**回滚日志会先于数据持久化到磁盘上**。这样就保证了**即使遇到数据库突然宕机**等情况，当用户再次启动数据库的时候，**数据库还能够通过查询回滚日志来回滚**将之前未完成的事务

### Spring支持两种方式的事务管理

#### 编程式事务管理

通过 **`TransactionTemplate`**或者**`TransactionManager`**手动管理事务，实际应用中很少使用。

前者示例代码：

```java
@Autowired
private TransactionTemplate transactionTemplate;
public void testTransaction() {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
            try {
                // ....  业务代码
            } catch (Exception e){
                //回滚
                transactionStatus.setRollbackOnly();
            }
        }
    });
}
```

后者示例代码：

```java
@Autowired
private PlatformTransactionManager transactionManager;
public void testTransaction() {
    TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    try {
        // ....  业务代码
        transactionManager.commit(status);
    } catch (Exception e) {
        transactionManager.rollback(status);
    }
}
```

#### 声明式事务管理

推荐使用（**代码侵入性最小**），实际是通过 **`AOP`** 实现（同样有两种方式，基于`TX`和`AOP`的`XML`配置文件方式和基于`@Transactional` 的全注解方式，后者使用最多）。

使用 `@Transactional`注解进行事务管理的示例代码如下：

```java
@Transactional(propagation = Propagation.REQUIRED)
public void aMethod {
  //do something
  B b = new B();
  C c = new C();
  b.bMethod();
  c.cMethod();
}
```

### Spring事务管理接口介绍

Spring 框架中，事务管理相关最重要的 3 个接口：

- **`PlatformTransactionManager`**：平台事务管理器，Spring事务策略的核心。
- **`TransactionDefinition`**：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。
- **`TransactionStatus`**：事务运行状态

可以把 **`PlatformTransactionManager`** 接口看作是**事务上层的管理者**，而 **`TransactionDefinition`** 和 **`TransactionStatus`** 这两个接口可以看作是**事务的描述**。

**`PlatformTransactionManager`** 会根据 **`TransactionDefinition`** 的**定义**（比如事务超时时间、隔离级别、传播行为等）来进行事务管理 ，而 **`TransactionStatus`** 接口则提供了一些**方法**来获取事务相应的状态比如是否新事务、是否可以回滚等等。

### 事务属性详解

实际业务开发中，大家一般都是使用 **`@Transactional`** 注解来开启事务。

事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。包含了 5 个方面：**隔离级别**、**传播行为**、**回滚规则**、**是否只读**和**事务超时**。

#### 事务传播行为

**事务传播行为是为了解决业务层方法之间互相调用的事务问题**。

例子：在 A 类的`aMethod()`方法中调用了 B 类的 `bMethod()` 方法。这个时候就涉及到业务层方法之间**互相调用的事务问题**。如果 `bMethod()`如果发生异常需要回滚，如何配置事务传播行为才能让 `aMethod()`也跟着回滚呢？

```java
@Service
Class A {
    @Autowired
    B b;
    @Transactional(propagation = Propagation.xxx)
    public void aMethod {
        //do something
        b.bMethod();
    }
}
@Service
Class B {
    @Transactional(propagation = Propagation.xxx)
    public void bMethod {
       //do something
    }
}
```

在`TransactionDefinition`定义中包括了如下几个表示传播行为的常量：

```java
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    ......
}
```

为了方便使用，Spring 相应地定义了一个枚举类：`Propagation`

```java
public enum Propagation {
    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),
    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),
    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),
    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),
    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),
    NEVER(TransactionDefinition.PROPAGATION_NEVER),
    NESTED(TransactionDefinition.PROPAGATION_NESTED);
    
    private final int value;
    
    Propagation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }
}
```

**正确的事务传播行为可能的值如下** ：

1. **`TransactionDefinition.PROPAGATION_REQUIRED`**

   使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解**默认**使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：

   - 如果**外部方法没有开启事务**的话，`Propagation.REQUIRED`修饰的内部方法会**新开启自己的事务**，且开启的事务**相互独立**，互不干扰。
   - 如果外部方法开启事务并且被`Propagation.REQUIRED`的话，所有`Propagation.REQUIRED`修饰的**内部方法和外部方法均属于同一事务** ，只要一个方法回滚，整个事务均回滚。

   如果上面的`aMethod()`和`bMethod()`使用的都是`PROPAGATION_REQUIRED`传播行为的话，两者使用的就是**同一个事务**，只要其中一个方法回滚，整个事务均回滚。

   ```java
   @Service
   Class A {
       @Autowired
       B b;
       @Transactional(propagation = Propagation.REQUIRED)
       public void aMethod {
           //do something
           b.bMethod();
       }
   }
   @Service
   Class B {
       @Transactional(propagation = Propagation.REQUIRED)
       public void bMethod {
          //do something
       }
   }
   ```

2. **`TransactionDefinition.PROPAGATION_REQUIRES_NEW`**

   创建一个**新的事务**，如果当前存在事务，则把当前事务挂起。也就是说**不管外部方法是否开启事务**，`Propagation.REQUIRES_NEW`修饰的**内部方法会新开启自己的事务**，且开启的事务相互独立，互不干扰。

   如果上面的`bMethod()`使用`PROPAGATION_REQUIRES_NEW`事务传播行为修饰，`aMethod`还是用`PROPAGATION_REQUIRED`修饰。如果`aMethod()`发生**异常回滚**，`bMethod()`不会跟着回滚，因为 `bMethod()`**开启了独立的事务**。但是，如果 `bMethod()`抛出了未被捕获的异常并且这个异常**满足事务回滚**规则的话，`aMethod()`**同样也会回滚**，因为这个异常被 `aMethod()`的事务管理机制检测到了。

   ```java
   @Service
   Class A {
       @Autowired
       B b;
       @Transactional(propagation = Propagation.REQUIRED)
       public void aMethod {
           //do something
           b.bMethod();
       }
   }
   @Service
   Class B {
       @Transactional(propagation = Propagation.REQUIRES_NEW)
       public void bMethod {
          //do something
       }
   }
   ```

3. **`TransactionDefinition.PROPAGATION_NESTED`**

   如果**当前存在事务**，就在**嵌套事务内执行**；如果**当前没有事务**，就执行与`TransactionDefinition.PROPAGATION_REQUIRED`类似的操作。也就是说：

   - 在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在。

   - 如果外部方法无事务，则**单独开启一个事务**，与 `PROPAGATION_REQUIRED` 类似。

   如果 `bMethod()` 回滚的话，`aMethod()`也会回滚。

   ```java
   @Service
   Class A {
       @Autowired
       B b;
       @Transactional(propagation = Propagation.REQUIRED)
       public void aMethod {
           //do something
           b.bMethod();
       }
   }
   @Service
   Class B {
       @Transactional(propagation = Propagation.NESTED)
       public void bMethod {
          //do something
       }
   }
   ```

4. 剩下4种使用很少

   - **`TransactionDefinition.PROPAGATION_MANDATORY`**：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）
   - **`TransactionDefinition.PROPAGATION_SUPPORTS`**: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
   - **`TransactionDefinition.PROPAGATION_NOT_SUPPORTED`**: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
   - **`TransactionDefinition.PROPAGATION_NEVER`**: 以非事务方式运行，如果当前存在事务，则抛出异常。

#### 事务隔离级别

`TransactionDefinition` 接口中定义了五个表示隔离级别的常量：

```java
public interface TransactionDefinition {
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
}
```

和事务传播行为那块一样，为了方便使用，Spring 也相应地定义了一个枚举类：`Isolation`。

```java
public enum Isolation {
  DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),
  READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),
  READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),
  REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),
  SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);

  private final int value;

  Isolation(int value) {
    this.value = value;
  }

  public int value() {
    return this.value;
  }
}
```

1. **`TransactionDefinition.ISOLATION_DEFAULT`** ：使用后端**数据库默认的隔离级别**，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别；Oracle 默认采用的 `READ_COMMITTED` 隔离级别。
2. **`TransactionDefinition.ISOLATION_READ_UNCOMMITTED`** :**读未提交**，最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
3. **`TransactionDefinition.ISOLATION_READ_COMMITTED`** : **读已提交**，允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
4. **`TransactionDefinition.ISOLATION_REPEATABLE_READ`** : **可重复读**，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**
5. **`TransactionDefinition.ISOLATION_SERIALIZABLE`** : **序列化**，最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将**严重影响程序的性能**。通常情况下也不会用到该级别。

#### 事务超时属性

所谓事务超时，就是指一个**事务所允许执行的最长时间**，如果超过该时间限制但事务还没有完成，则**自动回滚事务**。在 `TransactionDefinition` 中以 int 的值来表示超时时间，其单位是**秒**，默认值为**-1**，这表示事务的超时时间取决于底层事务系统或者没有超时时间。

#### 事务只读属性

对于只有读取数据查询的事务，可以指定事务类型为`readonly`，即**只读事务**。只读事务**不涉及数据的修改**，数据库会提供一些优化手段，适合用在有**多条数据库查询操作**的方法中。

```java
public interface TransactionDefinition {
    // 返回是否为只读事务，默认值为 false
    boolean isReadOnly();
}
```

- 如果你**一次执行单条**查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性。

- 如果你**一次执行多条**查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 **SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变**，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。

#### 事务回滚规则

规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到**运行期异常**（`RuntimeException` 的子类）时才会回滚，**`Error`** 也会导致事务回滚，但是，在遇到**检查型**（Checked）异常时不会回滚。

如果需要回滚自定义的特定异常类型，可以这样：

```java
@Transactional(rollbackFor= MyException.class)
```

### `@Transactional`注解使用详解

#### 作用范围

1. 方法：推荐将注解使用于方法上，不过需要注意的是：**该注解只能应用到 public 方法上，否则不生效。**
2. 类：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。
3. 接口：不推荐在接口上使用。因为一旦标注在Interface上并且配置了**Spring AOP 使用CGLib动态代理**，将会导致`@Transactional`注解失效。

#### 常用配置参数

源码如下，包含了基本事务属性的配置：

```java
public @interface Transactional {
	@AliasFor("transactionManager")
	String value() default "";
	@AliasFor("value")
	String transactionManager() default "";
	Propagation propagation() default Propagation.REQUIRED;
	Isolation isolation() default Isolation.DEFAULT;
	int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;
	boolean readOnly() default false;
	Class<? extends Throwable>[] rollbackFor() default {};
	String[] rollbackForClassName() default {};
	Class<? extends Throwable>[] noRollbackFor() default {};
	String[] noRollbackForClassName() default {};
}
```

|    属性名     |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
| `propagation` |             事务的传播行为，默认值为 `REQUIRED`              |
|  `isolation`  |             事务的隔离级别，默认值采用 `DEFAULT`             |
|   `timeout`   |            事务的超时时间，默认值为-1（不会超时）            |
|  `readOnly`   |            指定事务是否为只读事务，默认值为 false            |
| `rollbackFor` | 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型 |

#### 事务注解原理

`@Transactional` 的工作机制是**基于 AOP** 实现的，AOP 又是使用**动态代理**实现的。如果目标对象**实现了接口**，默认情况下会采用 **JDK** 的动态代理，如果目标对象**没有实现接口**，会使用 **CGLIB** 动态代理。

如果**一个类或者一个类中的 public 方法**上被标注`@Transactional` 注解的话，Spring 容器就会在启动的时候为其**创建一个代理类**，在调用被`@Transactional` 注解的 **public 方法**的时候，实际调用的是**`TransactionInterceptor` 类中的 `invoke()`方法**。这个方法的作用就是**在目标方法之前开启事务**，方法执行过程中如果遇到**异常的时候回滚事务**，方法调用**完成之后提交事务**。

##### Spring AOP自调用问题

**若同一类中，没有 `@Transactional` 注解的方法内部调用有 `@Transactional` 注解的方法，有`@Transactional` 注解的方法的事务会失效。**

这是由于`Spring AOP`代理的原因造成的，因为只有当 `@Transactional` **注解的方法在类以外被调用**的时候，Spring 事务管理才生效。

```java
@Service
public class MyService {
    private void method1() {
        method2();
}
    @Transactional
    public void method2() {
    }
}
```

上面的例子中，`MyService` 类中的`method1()`调用`method2()`就会导致`method2()`的事务失效。解决办法：**避免同一类中自调用**或者使用 **AspectJ 取代 Spring AOP** 代理。

### `@Transactional`失效场景

1. 应用在非public修饰的方法上

   `computeTransactionAttribute` 方法会检查目标方法的修饰符是否为 public，如果不是则不会获取`@Transactional` 注解的事务配置信息。

   ```java
   protected TransactionAttribute computeTransactionAttribute(Method method, Class<?> targetClass) {
       // Don't allow no-public methods as required.
       if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
           return null;
   }
   ```

   **注意：在`protected`、`private` 修饰的方法上使用 `@Transactional` 注解，虽然事务无效，但不会有任何报错。**

2. 属性`propagation`设置错误

   若是错误的配置以下三种 `propagation`，事务将不会发生回滚：

   1. **`TransactionDefinition.PROPAGATION_SUPPORTS`**
   2. **`TransactionDefinition.PROPAGATION_NOT_SUPPORTED`**
   3. **`TransactionDefinition.PROPAGATION_NEVER`**

3. 属性`rollbackFor`设置错误

   默认情况下，事务只有遇到**运行期异常**（`RuntimeException` 的子类）时才会回滚，**`Error`** 也会导致事务回滚，但是，在遇到**检查型**（Checked）异常时不会回滚。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 `rollbackFor`属性。

4. 同一个类中方法调用

   同一个类中的**无事务`a()`调用有事务`b()`就会导致`b()`的事务失效**，这是由于`Spring AOP`代理的原因造成的。

5. 异常被自己的`catch`捕获

   所以：在业务方法中一般不需要`catch`异常，如果非要`catch`一定要抛出`RuntimeException()`，或者注解中指定异常类型`@Transactional(rollbackFor=Exception.class)`，否则会导致事务失效。

6. 数据库的引擎不支持事务

   **数据库引擎是否支持事务是事务能否生效的关键**。比如常用的 MySQL 数据库默认使用**支持事务的 `innodb`引擎**。但是，如果把数据库引擎变为 `myisam`，那么程序也就不再支持事务了！

## `@ConfigurationProperties`:airplane:

用在配置类上，读取配置文件属性并与bean绑定。

```java
@Component
@ConfigurationProperties(prefix = "object")
public class TestConfig {
    private String name;
    // getter和setter方法省略
}
```

