# 多线程与并发

## 一、理论基础:airplane:

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-theorty.html)

### 1.1 为什么需要多线程？

众所周知，CPU、内存、I/O设备的速度是有极大差异的，为了合理利用CPU的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：

- CPU增加了缓存，以均衡与内存的速度差异——>导致**可见性**问题。
- 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异——>导致**原子性**问题。
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用——>导致**有序性**问题。

### 1.2 并发出现问题的根源：并发三要素

#### 可见性

可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。

#### 原子性

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

#### 有序性

有序性：即程序执行的顺序按照代码的先后顺序执行。

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：

![重排序](多线程与并发.assets/java-jmm-3.png)

上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。**对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序**（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，Intel称之为memory fence）指令，**通过内存屏障指令来禁止特定类型的处理器重排序**（不是所有的处理器重排序都要禁止）。

## 二、线程基础:airplane:

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-thread-basic.html)

### 2.1 线程状态转换

![线程状态转换](多线程与并发.assets/ace830df-9919-48ca-91b5-60b193f593d2.png)

### 2.2 线程使用方式

有三种使用线程的方法：

- 实现`Runnable`接口。
- 实现`Callable`接口。
- 继承`Thread`类。

实现`Runnable`和`Callable`接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过`Thread`来调用。可以说任务是通过线程驱动从而执行的。

#### 实现`Runnable`接口

需要实现`run()`方法，通过`Thread`调用`start()`方法来启动线程。

```java
public class MyRunnable implements Runnable {
    public void run() {
        // ...
    }
}

public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

#### 实现`Callable`接口

与`Runnable`相比，`Callable`可以有返回值，返回值通过`FutureTask`进行封装。

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

#### 继承`Thread`类

同样也是需要实现`run()`方法，因为`Thread`类也实现了`Runable`接口。当调用`start()`方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的`run()`方法。

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}

public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
```

#### 实现接口&继承

实现接口会更好一些，因为：

- Java不支持多重继承，因此继承了`Thread`类就无法继承其它类，但是可以实现多个接口。
- 类可能只要求可执行就行，继承整个`Thread`类开销过大。

### 2.3 线程互斥同步

Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的`synchronized`，而另一个是JDK实现的`ReentrantLock`。

#### synchronized

同步一个代码块，它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。

```java
public void func() {
    synchronized (this) {
        // ...
    }
}
```

同步一个方法，只作用于同一个对象。

```java
public synchronized void func () {
    // ...
}
```

同步一个类，作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。

```java
public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
```

同步一个静态方法，作用于整个类。

```java
public synchronized static void fun() {
    // ...
}
```

#### ReentrantLock

ReentrantLock是`java.util.concurrent`包中的锁。

```java
public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}
```

#### 比较

- **锁的实现**：`synchronized`是JVM实现的，而`ReentrantLock`是JDK实现的。
- **性能**：新版本Java对`synchronized`进行了很多优化，例如自旋锁等。
- **等待可中断**：当持有锁的线程长期不释放锁的时候，**正在等待的线程可以选择放弃等待**，改为处理其他事情。`ReentrantLock`可中断，而`synchronized`不行。
- **公平锁**：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。`synchronized`中的锁是非公平的，`ReentrantLock`默认情况下也是非公平的，但是也可以是公平的。
- **锁绑定多个条件**：一个`ReentrantLock`可以同时绑定多个`Condition`对象。

### 2.4 线程间协作

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。

#### `join()`

在线程中调用另一个线程的`join()`方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

#### `wait()`、`notify()`、`notifyAll()`

调用`wait()`使得线程等待某个条件满足，**线程在等待时会被挂起**，当其他线程的运行使得这个条件满足时，其它线程会调用`notify()`或者`notifyAll()`来唤醒挂起的线程。

使用`wait()`挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行`notify()`或者`notifyAll()`来唤醒挂起的线程，造成死锁。

#### `await()`、`signal()`、`signalAll()`

`java.util.concurrent`类库中提供了`Condition`类来实现线程之间的协调，可以在`Condition`上调用`await()`方法使线程等待，其它线程调用`signal()`或`signalAll()`方法唤醒等待的线程。相比于`wait()`这种等待方式，`await()`可以指定等待的条件，因此更加灵活。

## 三、Java中的锁

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-lock-all.html)

![Java的锁](多线程与并发.assets/java-lock-1.png)

### 3.1 乐观锁&悲观锁

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，**`synchronized`关键字和`Lock`的实现类都是悲观锁**；乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，**只是在更新数据的时候去判断之前有没有别的线程更新了这个数据**。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

- **悲观锁适合写操作多的场景**，先加锁可以保证写操作时数据正确。

- **乐观锁适合读操作多的场景**，不加锁的特点能够使其读操作的性能大幅提升。

### 3.2 自旋锁&非自旋锁

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

而为了让当前线程“稍等一下”，需让当前线程进行**自旋**，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

![自旋锁和非自旋锁](多线程与并发.assets/java-lock-4.png)

自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用`-XX:PreBlockSpin`来更改）没有成功获得锁，就应当挂起线程。

自旋锁的实现原理同样也是CAS，`AtomicInteger`中调用`unsafe`进行自增操作的源码中的`do-while`循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。

## 四、`synchronized`&`volatile`

> 参考链接：[Java全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html)、[Java全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html)

### 4.1 `synchronized`

#### 使用

在应用`sychronized`关键字时需要注意：

- 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待。
- 每个实例都对应有自己的一把锁，不同实例之间互不影响。
- `synchronized`修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。

##### 对象锁

包括方法锁（默认锁对象为`this`，当前实例对象）和同步代码块锁（自己指定锁对象）。

###### 方法锁

`synchronized`修饰普通方法，锁对象默认为`this`。

###### 代码块锁

手动指定锁定对象，可以是`this`，也可以是自定义的锁。

##### 类锁

指`synchronize`修饰静态的方法或指定锁对象为`Class`对象。

#### 原理



### 4.2 `volatile`